#include "${PROGNAME}.skel.h"

int attach_${PROGNAME}(struct args *conf, after_attach_fn_t cb)
{
    int err;
    char buf[100];
    buf[sizeof(buf) - 1] = '\0';

    // Skeleton
    struct ${PROGNAME}_bpf *obj = NULL;
    obj = ${PROGNAME}_bpf__open();
    if (!obj)
    {
        fprintf(stderr, "traffico: fail: opening the eBPF skeleton\n");
        return 1;
    }
    err = ${PROGNAME}_bpf__load(obj);
    if (err)
    {
        fprintf(stderr, "traffico: fail: loading the eBPF skeleton\n");
        goto destroy_${PROGNAME};
    }

    DECLARE_LIBBPF_OPTS(bpf_tc_hook, hook, .ifindex = conf->ifindex, .attach_point = conf->attach_point);
    err = bpf_tc_hook_create(&hook);
    if (err)
    {
        // Moving on in case the hook file already exists
        // TODO ? make this behavior configurable from arguments
        if (err != -EEXIST)
        {
            libbpf_strerror(err, buf, sizeof(buf));
            fprintf(stderr, "traffico: fail: creating the qdisc: %s\n", buf);
            goto destroy_${PROGNAME};
        }
        fprintf(stdout, "traffico: hook already existing, trying to re-use it\n");
    }

    // Attach the TC eBPF program to the qdisc
    int fd = bpf_program__fd(obj->progs.${PROGNAME});
    DECLARE_LIBBPF_OPTS(bpf_tc_opts, opts, .prog_fd = fd, .flags = BPF_TC_F_REPLACE);
    err = bpf_tc_attach(&hook, &opts);
    if (err)
    {
        libbpf_strerror(err, buf, sizeof(buf));
        fprintf(stderr, "traffico: fail: attaching the TC eBPF program: %s\n", buf);
        goto cleanup_${PROGNAME};
    }
    fprintf(stdout, "traffico: opts: handle: 0x%x\n", opts.handle);
    fprintf(stdout, "traffico: opts: priority: %d\n", opts.priority);
    fprintf(stdout, "traffico: opts: program ID: %d\n", opts.prog_id);

    err = cb(hook, opts);

cleanup_${PROGNAME}:
    if (conf->cleanup_on_exit)
    {
        // Force the cleanup of the qdisc as well
        hook.attach_point |= BPF_TC_INGRESS;
        err = bpf_tc_hook_destroy(&hook);
        if (err)
        {
            libbpf_strerror(err, buf, sizeof(buf));
            fprintf(stderr, "traffico: fail: destroying the qdisc: %s\n", buf);
        }
        fprintf(stdout, "traffico: done: destroying the qdisc\n");
    }

destroy_${PROGNAME}:
    if (conf->cleanup_on_exit)
    {
        ${PROGNAME}_bpf__destroy(obj);
    }

    return err < 0 ? -err : err;
}